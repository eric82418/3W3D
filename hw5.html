

<!DOCTYPE html>
<html>
<head>
<style>
#info {
    position: absolute;
    top: 0px;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
}
.fl {
    float:left;
    margin:20px;
}
.flc {
    float:right;
    margin:5px;
    width:5%;
}
body {
    overflow: auto;
}
</style>
</head>

<body>
<div id="container"></div>
<div id="info">
	<img src="images/picture_well.JPG" class="flc" onclick="javascript:tst(1);" />
    <img src="images/picture_well2.JPG" class="flc" onclick="javascript:tst(2);" />
	<img src="images/picture_well3.JPG" class="flc" onclick="javascript:tst(3);" />
    <img src="images/picture_well4.JPG" class="flc" onclick="javascript:tst(4);" />
</div>

    

<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
    
</script>

<script>


var camera, scene, renderer,light,light2,light3, controls;
var geometrypic, materialpic, meshpic,geometrypic2, materialpic2, meshpic2,geometrypic3, materialpic3, meshpic3,geometrypic4, materialpic4, meshpic4;
var geometrywell, materialwell, meshwell,geometrywell2, materialwell2, meshwell2,geometrywell3, materialwell3, meshwell3 ;
var floorgeometry, floormaterial, floormesh;
var tex1, tex2, tex3, tex4,welltex,picture,floortex;
var pickables = [];
var raycaster;
var mouse = new THREE.Vector2();
init();
animate();

function init() {
	renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);
	renderer.shadowMapEnabled = true;
    renderer.shadowMapType = THREE.PCFShadowMap;
	
    controls = new THREE.OrbitControls(camera, renderer.domElement);

    document.body.appendChild(renderer.domElement);
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
  
	camera.position.y = 250;
	camera.position.z = 500;
	camera.position.x = -250;
    scene.add(camera);

    //////////////////////////////////////////////////////
    THREE.ImageUtils.crossOrigin = '';
    tex1 = THREE.ImageUtils.loadTexture('images/picture_well.JPG');
    tex2 = THREE.ImageUtils.loadTexture('images/picture_well2.JPG');
	tex3 = THREE.ImageUtils.loadTexture('images/picture_well3.JPG');
    tex4 = THREE.ImageUtils.loadTexture('images/picture_well4.JPG');
    welltex = THREE.ImageUtils.loadTexture('images/well.jpg');
	floortex = THREE.ImageUtils.loadTexture('images/floorwoof.jpg');
	geometrypic = new THREE.PlaneGeometry(50, 34);
    materialpic = new THREE.MeshLambertMaterial({ color: 0xffffff ,polygonOffset: true,polygonOffsetUnits: -4.0,polygonOffsetFactor: -1.0});

    meshpic = new THREE.Mesh(geometrypic, materialpic);
	meshpic.position.set(0,0,0);
    
	
	
	geometrypic2 = new THREE.PlaneGeometry(50, 34);
    materialpic2 = new THREE.MeshLambertMaterial({color: 0xffffff ,polygonOffset: true,polygonOffsetUnits: -4.0,polygonOffsetFactor: -1.0});

    meshpic2 = new THREE.Mesh(geometrypic2, materialpic2);
	meshpic2.position.set(0,0,0);

	
	geometrypic3 = new THREE.PlaneGeometry(50, 34);
    materialpic3 = new THREE.MeshLambertMaterial({color: 0xffffff ,polygonOffset: true,polygonOffsetUnits: -4.0,polygonOffsetFactor: -1.0});

    meshpic3 = new THREE.Mesh(geometrypic3, materialpic3);
	meshpic3.position.set(0,0,0);
   
	
	geometrypic4 = new THREE.PlaneGeometry(50, 34);
    materialpic4 = new THREE.MeshLambertMaterial({color: 0xffffff ,polygonOffset: true,polygonOffsetUnits: -4.0,polygonOffsetFactor: -1.0});

    meshpic4 = new THREE.Mesh(geometrypic4, materialpic4);
	meshpic4.position.set(0,0,0);
   

	geometrywell = new THREE.BoxGeometry(100, 100,8);
    materialwell = new THREE.MeshLambertMaterial({map:welltex});
	
	meshwell = new THREE.Mesh(geometrywell, materialwell);
	meshwell.position.set(-0,50,57);
	meshwell.rotation.y = 1.57;
    scene.add(meshwell);
	
	geometrywell2 = new THREE.BoxGeometry(200, 100,8);
    materialwell2 = new THREE.MeshLambertMaterial({map:welltex});
	
	meshwell2 = new THREE.Mesh(geometrywell2, materialwell2);
	meshwell2.position.set(0,50,-54);
    scene.add(meshwell2);
	
	geometrywell3 = new THREE.BoxGeometry(150, 100,8);
    materialwell3 = new THREE.MeshLambertMaterial({map:welltex});
	
	meshwell3 = new THREE.Mesh(geometrywell3, materialwell3);
	meshwell3.position.set(100,50,17);
	meshwell3.rotation.y = 1.57;
    scene.add(meshwell3);
	
	floorgeometry = new THREE.BoxGeometry(250, 250,2);
    floormaterial = new THREE.MeshLambertMaterial({map:floortex});
	
	floormesh = new THREE.Mesh(floorgeometry, floormaterial);
	floormesh.rotation.x = -1.57;
    scene.add(floormesh);
	
	light = new THREE.PointLight(0xffffff,0.5);
    light.position.set(100, 300, 200);
    scene.add(light);
	
    light2 = new THREE.PointLight(0xffffff,0.5);
    light2.position.set(-100, 300, 200);
    scene.add(light2);
	
	pickables = [meshwell,meshwell2,meshwell3];
	
   

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    // the following is not needed for "embed" mode
    document.body.appendChild(renderer.domElement);
	raycaster = new THREE.Raycaster();
    document.addEventListener('mousedown', onDocumentMouseDown, false);
}

// remember "no warp in <body>"
//
function tst(which) {

    if (which === 1) {
        //alert("click");
        meshpic.material = new THREE.MeshBasicMaterial({
            map: tex1,
            side: THREE.DoubleSide,
			polygonOffset: true,
			polygonOffsetUnits: -4.0,
			polygonOffsetFactor: -1.0
        });
		scene.add(meshpic); 
		picture=meshpic;
    } else if (which === 2) {
        meshpic2.material = new THREE.MeshBasicMaterial({
            map: tex2,
            side: THREE.DoubleSide,
			polygonOffset: true,
			polygonOffsetUnits: -4.0,
			polygonOffsetFactor: -1.0
        });
		scene.add(meshpic2); 
		picture=meshpic2;
    }else if (which === 3) {
        meshpic3.material = new THREE.MeshBasicMaterial({
            map: tex3,
            side: THREE.DoubleSide,
			polygonOffset: true,
			polygonOffsetUnits: -4.0,
			polygonOffsetFactor: -1.0
        });
		scene.add(meshpic3); 
		picture=meshpic3;
    }else if (which === 4) {
        meshpic4.material = new THREE.MeshBasicMaterial({
            map: tex4,
            side: THREE.DoubleSide,
			polygonOffset: true,
			polygonOffsetUnits: -4.0,
			polygonOffsetFactor: -1.0
        });
		scene.add(meshpic4); 
		picture=meshpic4;
    }
    // debugger;
}

function onDocumentMouseDown(event) {

    // PICKING DETAILS: 
    // convert mouse.xy = [-1,1]^2 (NDC)
    // unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
    // set raycaster (origin, direction)
    // find intersection objects, (closest first) 
    // each record as
    // [ { distance, point, face, faceIndex, object }, ... ]

    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    // find intersections
    var vector = new THREE.Vector3(mouse.x, mouse.y, 1).unproject(camera);
    raycaster.set(camera.position, vector.sub(camera.position).normalize());
    var intersects = raycaster.intersectObjects(pickables);
    if (intersects.length > 0) {
        debugger;
        picture.position.copy(intersects[0].point);
        picture.rotation.copy (intersects[0].object.rotation);

    }

}

function animate() {
    controls.update();

    requestAnimationFrame(animate);
    render();
}

function render() {
    renderer.render(scene, camera);
}


</script>
</body>

</html>



